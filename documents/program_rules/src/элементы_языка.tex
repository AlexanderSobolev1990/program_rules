%\newpage
\vspace{1cm}
\section{Элементы языка}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Средства, запрещенные к использованию}

Язык С++ и стандартные библиотеки предоставляют программисту широкий выбор различных средств программирования. Однако непродуманное использование некоторых средств может привести к тяжелым и труднообнаруживаемым ошибкам в программе. Ниже перечисляются средства, использование которых запрещается без разрешения руководителя проекта:

\begin{enumerate}
	\item Запрещено использовать какие-либо средства выделения памяти, кроме оператора \lstinline|new|. В частности, категорически запрещено использовать функцию \lstinline|malloc|.
	\item Категорически запрещено использовать функции \lstinline|strcpy| и \lstinline|strcat|.
%	\item 
	\item Запрещено использовать исключения, не выведенные из базового класса исключений.% \textbf{(ПОД СОМНЕНИЕМ)}
	\item Запрещено создавать новые макросы, за исключением специально оговоренных случаев (см. ниже).
	\item Запрещено инициализировать структуры, за исключением массивов структур, списком инициализаторов.% \textbf{(ПОД СОМНЕНИЕМ)}
\end{enumerate}

Нежелательно использовать виртуальное наследование (\lstinline|virtual|) в конечном продукте. Использование виртуального наследования может быть оправданно в исследовательских проектах, когда необходимо, например, создать сходные и мало отличающиеся по пользовательскому функционалу объекты.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Выбор идентификаторов}

Основное требование к выбору идентификаторов\mdash понятность. Следует избегать непонятных сокращений, бессмысленных или однобуквенных идентификаторов (кроме переменных цикла \lstinline|i, j, k|). Кроме того, на выбор идентификатора налагается ряд формальных и неформальных ограничений.

Желательно, чтобы по идентификатору объекта или метода можно было понять, для чего объект или метод предназначен. Это означает, что по возможности идентификаторы должны быть осмысленными выражениями. Однако не стоит впадать и в другую крайность: слишком длинные идентификаторы загромождают выражения. Обычно идентификатор должен быть не длиннее 15\mbdash 20 символов. При этом более простым и часто используемым объектам и методам следует давать более короткие идентификаторы, более сложным и редко используемым объектам и методам, а также глобальным объектам – более длинные, но более понятные.

Общее правило образования идентификаторов: идентификатор состоит из отдельных слов или частей слов, написанных маленькими буквами, причем второе и последующие слова всегда начинаются с большой буквы (\lstinline|prevItem, DefaultUserMsg|) (подчеркивание для разделения слов не используется).

Начинать идентификатор с символа подчеркивания разрешается только для устранения конфликта между именем аргумента метода класса и именем поля этого класса. Например, если в классе \lstinline|CPoint| есть два поля с именами x и y, то конструктор этого класса может иметь аргументы с именами \lstinline|_x и _y| или \lstinline|x_ и y_|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Обязательные правила образования имен}

\paragraph{Перечисления} % \lstinline|enum|

К имени элемента перечисления добавляется приставка, образованная из первых букв слов, составляющих название перечисляемого типа. После приставки ставится символ подчеркивания.

\begin{lstlisting}[caption=\raggedright{Образование имени перечисления}, frame=single]
enum TInputMode {
    IM_Scaner,
    IM_Batch,
    IM_File
};
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Константы}

Имена для констант пишутся с большой буквы. Иногда допустимо использовать все заглавные буквы в названии константы (если так принято в соответствующей дисциплине/науке/направлении или если название константы\mdash аббревиатура): 

\begin{lstlisting}[frame=single,numbers=none]
const int Re = 6371; ///< Радиус Земли, [км]
const int ID = 120; ///< Идентификатор
const int VGC = 2; ///< Очень хорошая константа (very good const)
\end{lstlisting}

%Пример: \lstinline|const int Re = 6371;|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Классы, структуры}

Имена классов и структур начинаются с приставки <<C>>, слово за которой начинается с большой буквы. 

\begin{lstlisting}[frame=single,numbers=none]
class CWorker
struct CWorkerParams
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Интерфейсы}

Имена для интерфейсов начинаются с приставки <<I>>, слово за которой начинается с большой буквы.

\begin{lstlisting}[frame=single,numbers=none]
IBlock, ISubsystem
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Пространства имен}

Имена для пространств имен начинаются с большой буквы и не имеют какой-либо специальной приставки.

\begin{lstlisting}[frame=single]
namespace MyNamespace /// Мое пространство имен
{
...
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Определения типов}

Имена typedef-ов начинаются с большой буквы. Имена typedef-ов для структур и классов начинаются с большой буквы <<C>>. Имена других типов, не являющихся классами и структурами, начинаются с большой буквы <<T>>.

\begin{lstlisting}[frame=single,numbers=none]
typedef const BYTE *TBytePtr;
typedef const CMYCLASS *CMyClass;
typedef const CMYSTRUCT *CMyStruct;
typedef const TMYENUM *TMyEnum;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Переменные}

Имена глобальных переменных пишутся с большой буквы. Имена локальных переменных и параметров методов пишутся с маленькой буквы. Запрещено добавлять к именам переменных префикс, зависящий от типа данных (так называемая, <<венгерская нотация>>).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Функции/методы класса}

Имена глобальных функций начинаются с большой буквы. Имена статических функций начинаются с маленькой буквы.
Регистр буквы, с которой начинаются имена членов класса (полей и методов) зависит от характера их использования:

\begin{enumerate}
\item при локальном использовании полей или методов, служащих только для реализации класса или библиотеки, используется маленькая буква;
\item если поле или метод используется вне этого класса, то употребляется большая буква (под использованием здесь подразумевается не только доступ к членам класса, но также и переопределение при наследовании).
\end{enumerate}

Очевидно, что в такой системе \lstinline|private| члены должны начинаться с маленькой буквы, а \lstinline|public| и \lstinline|protected|\mdash обычно с большой буквы.
Имена статических полей класса пишутся также, как и имена обычных полей.

Запрещено добавлять к именам полей класса префикс \lstinline|m_<имя поля>| (данная система именования используется в библиотеке MFC).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Использование сокращений в именах}

Следует избегать использования сокращений в качестве части имени. Заведомо не нужно использовать сокращения, если без их использования идентификатор имеет приемлемую длину.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Рекомендации по образованию имен}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Бинарный атрибут}

Для полей классов, которые по своей сути являются бинарными атрибутами, имя в большинстве случаев должно начинаться с приставки <<is>> или <<has>>. Например, для класса \lstinline|СStream| можно завести переменную \lstinline|isOpen|. Методы, которые возвращают бинарную характеристику объекта, также рекомендуется начинать с этой приставки.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Количество элементов}

Если переменная служит для хранения количества элементов в каком либо списке или массиве, то к названию такой переменной следует добавлять приставку <<numberOf>> или суффикс <<count>>. Например, переменная, указывающая количество свободных блоков в менеджере памяти, может называться \lstinline|numberOfFreeBlocks| или \lstinline|freeBlocksCount|. Вместо приставки <<numberOf>> допустимо сокращение <<n>>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Размер/длина}

Слово <<Size>> применяется для переменных и методов, задающих размер (число байт).
Слово <<Len>> (или <<Length>>) используется в имени переменных и методов, служащих для задания числа элементов.
Замечание: Слово <<Size>>\mdash это размер, а <<Length>>\mdash длина. Не следует размер блока памяти называть blockLen, а длину строки\mdash stringSize.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Методы получения бинарного атрибута}

Имя метода получения бинарного атрибута должно быть предикатом (вопросом, на который можно ответить Да или Нет). В большинстве случаев имя метода должно начинаться с глаголов <<Is>> или <<Has>>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Методы получения и установки небинарного атрибута}

Обычно метод получения небинарного атрибута называется также как и \lstinline|private| атрибут, только его имя начинается с большой буквы. Допускается добавление к названию метода получения атрибута глагола <<Get>>. Если кроме метода получения атрибута в классе есть также метод установки атрибута, то названия этих методов должны начинаться с глаголов <<Get>> и <<Set>> соответственно.

Если для получения возвращаемого значения требуются нетривиальные вычисления, название метода обычно начинается с глагола, описывающего эти вычисления, например <<Find>>. Такой метод обычно не приводит к изменению состояния объекта и должен объявляться как константный. Запрещается начинать имя метода, требующего нетривиальных вычислений, с глагола <<Get>>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Методы, производящие действие}

Методам, изменяющим объект либо внешние по отношению к объекту данные, даются имена, начинающиеся с глагола, обозначающего это действие. Например, \lstinline|FilterDust(), BuildTree()| и т.~п. Часто такими глаголами являются <<Do, Make, Process>>.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Правила форматирования текста}

Во всех случаях без исключения после запятой ставится пробел.

Текст выравнивается с помощью табуляции размером 4 пробела, комментарии отделяются пробелом:

\begin{lstlisting}[frame=single,showspaces=true,showstringspaces=true]
namespace MyNamespace /// Мое пространство имен
{
class CWorker
{
    int someField;
    void someMethod
    {
        // Do smth...
    }
};// end class CWorker
}// end namespace MyNamespace
\end{lstlisting}

При особо длинных конструкциях (и отсутствия необходимости их рефакторить для уменьшения длины) рекомендуется добавлять в конце комментарий какая именно конструкция закрывается (см.~в~листинге выше \lstinline|// end class CWorker, // end namespace MyNamespace|). Также рекомендуется комментировать это для вложенных циклов:
\begin{lstlisting}[frame=single]
for( int i = 0; i < I; i++ ) {
    for( int j = 0; j < J; j++ ) {
        //		
		// Много текста
        //
    }// end for j
    for( int k = 0; k < K; k++ ) {
        //		
        // Много текста
        //
    }// end for k
}// end for i
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Комментарии}

Для написания комментариев следует пользоваться правилами разметки, принятыми в система разметки исходного кода doxygen \cite{Doxygen}.

Система doxygen допускает применение различных стилей многострочных\footnote{Такие комментарии начинаются с новой строки (первого столбца строки).} комментариев \cite{DoxygenКомментарии}:
\begin{enumerate}
\item Javadoc стиль:
\begin{lstlisting}[frame=single]
/**
* ... text ...
*/
\end{lstlisting}
\item Qt стиль:
\begin{lstlisting}[frame=single]
/*!
* ... text ...
*/
\end{lstlisting}
\item C++ стиль:
\begin{lstlisting}[frame=single]
///
/// ... text ...
///
\end{lstlisting}
\end{enumerate}

Разрешается использовать для многострочных комментариев вариант №3, то есть три косые черты \lstinline|///|.
Дольшинство \acsu{ide} (например, QtCreator) поддерживают автосоздание тегов разметки для классов, методов и т.д.: достаточно поставить курсор выше комментируемой строки, набрать \lstinline|///| и нажать клавишу <<Enter>>.

Однострочный комментарий, идущий строго после текста, который он комментирует, должен оформляться как \lstinline|///<|, то есть добавлением символа \lstinline|<| к чертам. Без данного символа комментарий не будет распознан doxygen. Исключение\mdash комментирование пространства имен, где \lstinline|<| добавлять не следует

\begin{lstlisting}[frame=single]
namespace MyNamespace /// Мое пространство имен
{
    ...
}// end namespace MyNamespace
\end{lstlisting}

Для комментариев, которые не предполагается извлекать при помощи doxygen, следует пользоваться двойной косой чертой \lstinline|//|.

Комментарии вида \lstinline|/*| и \lstinline|*/| являются нежелательными. Целесообразно временно применять их для быстрого комментирования больших участков кода при отладке. В release-версии таких комментариев не должно быть. 

Текст комментария всегда начинается с заглавной буквы, точка в конце не ставится. Если в комментарии несколько предложений, то точка между ними ставится, в конце\mdash нет.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Стандартный заголовок файла}

Следует использовать заголовок, размеченный согласно правилам doxygen. Минимально применимый заголовок:

\begin{lstlisting}[frame=single]
///
/// \file       myclass.h
/// \brief      Класс такой-то для того-то и того-то
/// \date       30.10.19
/// \author     Иванов И.И.
///
\end{lstlisting}

Описание обязательно должно быть в \lstinline|*.h| файлах, но может отсутствовать в соответствующих им \lstinline|*.cpp| файлах. Заголовок начинается с первой строки любого файла, содержащего текст программы, и отделен от остального текста пустой строкой.
 
Следует уделять особое внимание описанию содержимого файла в стандартном заголовке. 
Doxygen предлагает большое количество тегов для разметки, наиболее используемыми являются:
\begin{enumerate}
\item \textbackslash file\mdash название файла;
\item \textbackslash brief\mdash краткое описание;
\item \textbackslash data\mdash дата создания файла;
\item \textbackslash author\mdash автор/авторы через запятую;
\item \textbackslash param\mdash параметр функции/метода;
\item \textbackslash attention\mdash сообщение на что обратить особое внимание;
\item \textbackslash warning\mdash предупреждение.
\end{enumerate}

В описании под тегом \lstinline|\remarks| или \lstinline|\details| желательно указано назначение классов данного файла.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Комментирование исходного текста программы}

Целью комментирования исходного текста программы является облегчение его понимания. Уместный и адекватный комментарий значительно упрощает сопровождение программы, и его важность несомненна.

Комментарии в разрабатываемых файлах пишутся на русском языке, исключение составляет legacy\sdash код.

Следует помнить, что комментарии в \lstinline|*.h| файле пишутся для человека, который будет использовать класс, а комментарии в \lstinline|*.cpp| файле пишутся для человека, который будет поддерживать класс.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Что нужно комментировать?}

Обязательно наличие комментария в следующих случаях:

\begin{enumerate}
\item Общий комментарий к содержимому файла в стандартном заголовке файла.
\item Объявление каждого класса в заголовочном файле.
\item Объявление каждого поля класса, включая \lstinline|private| и \lstinline|protected| поля.
\item Объявление каждого метода класса, включая \lstinline|private| и \lstinline|protected| методы. Исключением являются стандартные методы, такие как конструкторы копирования, конструкторы по умолчанию, деструкторы и операторы присваивания. Можно не комментировать методы получения/установки значения поля класса.
\item Объявление глобальных и статических переменных и функций.
\item Элементы перечислимых типов (\lstinline|enums|).
\item Все нетривиальные решения в реализации функций и методов.
\end{enumerate}
Если класс является реализацией какого\sdash либо интерфейса, то можно не писать отдельный комментарий к каждому виртуальному методу этого интерфейса. Достаточно написать общий комментарий перед всей группой этих виртуальных методов.

Комментарии перед шаблонными функциями или классами должны содержать описание аргументов шаблона. Комментарии перед методами классов, операторами или функциями должны содержать описание параметров.

Комментарий должен описывать прежде всего назначение комментируемого класса, поля или метода. Комментарий не должен быть просто переводом на русский язык названия комментируемой сущности.

%Комментарии к \lstinline|public| и \lstinline|protected| методам класса пишутся внутри объявления класса. Комментарии к \lstinline|private| методам пишутся перед реализацией этого метода.

Категорически запрещается использовать комментарии для удаления кода. Если вы удаляете код, то надо его удалять, а не комментировать. Исключением может быть случай, когда вы намереваетесь использовать этот код, но по тем или иным причинам не можете сделать это немедленно. В таких случаях в начале кода должен идти текст на русском языке, в котором говорится, что это за код и где вы его намерены использовать.

При модификации методов нужно тщательно следить за тем, чтобы комментарии, особенно в заголовочных файлах, правильно отражали их семантику, особенности использования и реализации.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Определение классов}

\begin{lstlisting}[frame=single]
///
/// \brief Класс моего окна
///
class СMyWindow : public CWindow 
{
    DECLARE_MESSAGE_MAP() ///< Обявление того-то
	
public:
    CMyWindow(); ///< Конструктор по-умолчанию
	
    ///
    /// \brief Параметрический конструктор
    /// \param param1 - первый параметр
    /// \param param2 - второй параметр
    ///	
    СMyWindow( int param1, int param2 );
	
    ~СMyWindow();
	
    int MyMethod(); ///< Метод делающий то-то
    void ConstantMethod() const; ///< Метод делающий сё-то
	
private:
    int value; ///< Значение такое-то
    
    int myMethod1(); ///< Метод делающий то-то
    int myMethod2(); ///< Метод делающий сё-то
};
\end{lstlisting}

Порядок размещения разделов должен быть следующим: \lstinline|public, protected, private|. В пределах каждого раздела сначала идут описания полей, потом пустая строка и описания методов. Между двумя разделами всегда стоит пустая строка. Все содержимое фигурных скобок, за исключением слов \lstinline|public, protected, private|, выделено на одну табуляцию. 
%Особо внимание следует обратить на то, что открывающая фигурная скобка стоит на той же строке, что и имя класса.
Запрещается опускать ключевое слово \lstinline|private| для классов только с приватными полями.

В описаниях методов сначала должны идти все конструкторы, затем деструктор. После описания деструктора, перед описанием следующего метода должна быть пустая строка.

Ключевое слово \lstinline|const| в объявлении метода пишется на той же строке и отделяется пробелом от закрывающей круглой скобки.

Макросы типа \lstinline|DECLARE_MESSAGE_MAP| и т.п. вставляются в начале блока до ключевого слова \lstinline|public|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Определение методов}

\begin{lstlisting}[frame=single]
int CMyClass::MyMethod()
{
    int i = 0;
    return i;
}
\end{lstlisting}

Тело метода сдвигается на одну табуляцию (4 пробела). Запрещается ставить открывающую скобку на одной строке с именем метода. Запрещается ставить точку с запятой после закрывающейся фигурной скобки тела метода.

Это правило касается также определения \lstinline|inline| методов, сделанного вне класса.

Особый случай\mdash определение конструктора:

\begin{lstlisting}[frame=single]
CMyClass::CMyClass( int intParam, bool boolParam ) :
    intField( intParam ),
    boolField( boolParam )
{}
\end{lstlisting}

После закрывающей скобки через пробел ставится двоеточие и на следующих строках записываются выражения инициализации баз и членов. Сначала записываются выражения инициализации всех баз, а затем членов. Все выражения инициализации сдвинуты на одну табуляцию.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Определение inline методов}

При определении \lstinline|inline| методов возможен один из двух стилей форматирования:

\begin{lstlisting}[frame=single]
class СMyClass
{
    int myMethod1() { return myVar; }
    int myBigMethod( int param );
};
\end{lstlisting}
и

\begin{lstlisting}[frame=single]
inline int CMyClass::myBigMethod( int param )
{
    assert( param > 0 );
    return param * 2;
}
\end{lstlisting}

В первом случае после открывающей и перед закрывающей фигурной скобкой стоит пробел. Запрещается ставить точку с запятой после закрывающейся фигурной скобки тела метода.

При использовании первого метода для определения конструкторов выражения инициализации баз и членов  записываются в строку сразу после закрывающей скобки параметров конструктора. Перед и после двоеточия ставится по одному пробелу.

В определении класса следует включать только однострочные \lstinline|inline| методы. Если метод занимает несколько строк, то лучше определить этот метод в этом же заголовочном файле после определения класса, используя ключевое слово \lstinline|inline|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Оформление оператора <<if>>}

\begin{lstlisting}[frame=single]
if( !isOpen ) {
    DoOpen();
}

if( str.Length() > 0 ) {
    // Do smth
} else {
    // Do smth else
}
\end{lstlisting}

Внутренние блоки сдвинуты на табуляцию. Пробел не ставится между <<if>> и <<(>>. Пробел ставится между <<)>> и <<{>>, до и после <<else>>. Запрещается писать открывающие фигурные скобки на отдельной строке (кроме случая сложного условия), равно как и разносить <<else>> и прилегающие фигурные скобки на несколько строк.
	
Фигурные скобки необходимо обязательно использовать, даже если блок содержит только один простой оператор. Запрещается ставить точку с запятой после закрывающейся фигурной скобки.

\begin{lstlisting}[frame=single]
if( hasObject() ) {
    processObject();
} else {
    skip();
}
\end{lstlisting}

Допускается написание цепных условий в следующем формате:

\begin{lstlisting}[frame=single]
if( isspace( c ) ) {
    ProcessSpace();
} else if( isdigit( c ) ) {
    ProcessDigit();
} else if( isalpha( c ) ) {
    ProcessLetter();
} else {
    assert( false );
}
\end{lstlisting}

Этот способ применяется  вместо использования оператора \lstinline|switch| только для условий сложного вида, когда \lstinline|switch| использовать невозможно. При этом нужно для всех блоков использовать фигурные скобки.

В случае сложного условия рекомендуется следующий способ записи оператора:

\begin{lstlisting}[frame=single]
if( term1
    && term2
    && term3
    && term4 )
{	
	DoSomething();
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Оформление оператора <<for>>}

\begin{lstlisting}[frame=single]
for( int i = 0; i < array.Size(); i++ ) {
    Process( array[i] );
}
\end{lstlisting}

Внутренний блок сдвинут на табуляцию. Между <<for>> и <<(>> пробел не ставится, а между <<)>> и <<{>> стоит пробел. Запрещается писать открывающую фигурную скобку на отдельной строке, за исключением случая сложного условия. Запрещается ставить точку с запятой после закрывающейся фигурной скобки. Если условие цикла не помещается на одной строке, то вторая и последующая строки условия сдвигаются на табуляцию, а открывающаяся фигурная скобка ставится на отдельной строке:
	
\begin{lstlisting}[frame=single]
for( int i = 0; i < array.Size() && IsValid( array[i] )
    && CanProcess( array[i] ); i++ )
{
    Process( array[i] );
}
\end{lstlisting}

Фигурные скобки необходимо обязательно использовать, даже если блок содержит только один простой оператор. В вырожденном случае, когда тело цикла пустое, необходимо также пользоваться фигурными скобками:

\begin{lstlisting}[frame=single]
for( int i = 0; i < array.Size() && IsValid( array[i] ); i++ ) {
    ...
}

for( int i = 0; i < array.Size() && IsValid( array[i] ); i++ ) {
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Оформление оператора <<while>>}

\begin{lstlisting}[frame=single]
while( i > 0 ) {
    cout << i;
    i--;
}
\end{lstlisting}

Внутренний блок сдвинут на табуляцию. Между <<while>> и <<(>> пробел не ставится, а между <<)>> и <<{>> стоит пробел. Запрещается писать открывающую фигурную скобку на отдельной строке, за исключением случая сложного условия. Запрещается ставить точку с запятой после закрывающейся фигурной скобки. Если условие цикла не помещается на одной строке, то вторая и последующая строки условия сдвигаются на табуляцию, а открывающаяся фигурная скобка ставится на отдельной строке:
	
\begin{lstlisting}[frame=single]
while( CanProcess( i, object ) && i > 0
    && IsValid( i ) )
{
    Process( i, object );
    i--;
}
\end{lstlisting}	

Фигурные скобки необходимо обязательно использовать, даже если блок содержит только один простой оператор. В вырожденном случае, когда тело цикла пустое, необходимо также пользоваться фигурными скобками:

\begin{lstlisting}[frame=single]
while( ( *ptr1++ = *ptr2++ ) != 0 ) {
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Оформление оператора <<do ... while>>}

\begin{lstlisting}[frame=single]
do {
    ret = Process();
} while( ret > 0 );
\end{lstlisting}

Внутренний блок сдвинут на табуляцию. Между <<do>> и <<{>> и между <<}>> и <<while>> стоит пробел. Фигурные скобки не опускаются, даже если тело цикла состоит из одного оператора. Запрещается писать фигурные скобки на отдельной строке.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Оформление оператора <<switch>>}

\begin{lstlisting}[frame=single]
switch( source ) {
    case S_Scaner:
        ScanImage();
        break;
    case S_Image:
    case S_File: 
    {
        CString name = getName();
        ReadImage( name );
        break; 
    }
    default:
        assert( false );
}
\end{lstlisting}

Метки \lstinline|case| сдвинуты на табуляцию, а сам код сдвинут на две табуляции. Пробел после метки \lstinline|case| перед двоеточием не ставится.

В конце секции обязательно необходимо ставить оператор \lstinline|break|. Единственное исключение\mdash когда несколько меток относятся к одной секции кода. Семантика оператора \lstinline|switch| не должна зависеть от порядка расположения секций.

Если в какой\sdash либо из секций содержится определение переменной, то данная секция должна быть заключена в фигурные скобки. Открывающаяся фигурная скобка ставится на отдельной строке после метки \lstinline|case|. Закрывающаяся скобка ставится на отдельной строке после оператора \lstinline|break|. Открывающаяся и закрывающаяся скобки сдвинуты на табуляцию относительно оператора \lstinline|switch| и находятся на одном уровне с метками \lstinline|case|.

Секция \lstinline|default| всегда идет последней.

Запрещается ставить точку с запятой после закрывающейся фигурной скобки оператора \lstinline|switch|. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Оформление лямбда-выражений}

Лямбда\sdash выражения представляют более краткий компактный синтаксис для определения объектов\sdash функций.
Необходимость использования лямбд следует согласовывать с руководителем проекта в каждом конкретном случае.
Примеры оформления приведены ниже.

Простой пример:
\begin{lstlisting}[frame=single]
struct CMyStruct
{
    int x, y;
    int operator()( int );
    void f()
    {
        [=]()->int {
            return operator()( this->x + this->y );
        };
    }
};
\end{lstlisting}

Пример с использованием внутри \lstinline|std::function|:
\begin{lstlisting}[frame=single]
std::function<arma::vec( const arma::vec &vectorA )> myMethod =
    [&]( const arma::vec &vectorA )->arma::vec {
        arma::vec res;
        // ...
        return res;
    };
\end{lstlisting}

Пример с использованием внутри \lstinline|std::transform|:
\begin{lstlisting}[frame=single]
void func( std::vector<double> &v, const double &e ) 
{
    std::transform( v.begin(), v.end(), v.begin(), [e]( double d )->double {
        if( d < e ) {
            return 0;
        } else {
            return d;
        }
    } );
}
\end{lstlisting}

\newpage

Пример с использованием внутри \lstinline|std::transform| и с переносом длинной строки:
\begin{lstlisting}[frame=single]
void func( std::vector<double> &v, const double &epsilon ) 
{
    std::transform( v.begin(), v.end(), v.begin(), // Перенос длинной строки
        [epsilon]( double d )->double 
    {
        if( d < epsilon ) {
	        return 0;
		} else {
		    return d;
		}
	} );
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Написание прочих выражений}

Изложенное ниже касается также списка параметров метода и объявления переменных. Приведенные правила не охватывают всех аспектов, оставшиеся детали остаются на усмотрение программиста.

\begin{enumerate}
\item После запятой пробел ставится всегда, перед запятой\mdash никогда.
\item Если после открывающей круглой скобки стоит пробел, то перед парной закрывающей скобкой тоже должен стоять пробел, и наоборот.
\item После <<[>> и перед <<]>> пробелы не ставятся.
\item Бинарные операции (кроме \lstinline|-> . :: .* ->*|) с двух сторон окружаются пробелами.
\item Унарные операции пишутся слитно с операндом.
\item Операция << ? : >>  пишется с пробелами вокруг <<?>> и <<:>>
\item В описании переменных <<*>> и <<\&>> примыкают к переменной:
\begin{lstlisting}[frame=single,numbers=none]
int *ptr;
int &var;
\end{lstlisting}
однако если после <<*>> и <<\&>> должно стоять \lstinline|const|, то это может записываться следующим образом:
\begin{lstlisting}[frame=single,numbers=none]
int *const constPtr;
\end{lstlisting}
\item После типа стоит всегда один пробел.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Несколько классов в одном файле}\label{subsubsection:Несколько_классов_в_одном_файле}

Если в одном файле содержится объявления нескольких классов, их следует разделять строкой вида:

\begin{lstlisting}[frame=single,numbers=none]
...
}; // end CSomeClass

//--------------------------------------------------------------------------
///
/// \brief Другой класс
///
class CAnotherClass
{
...
\end{lstlisting}

Этот же разделитель используется, если в одном файле содержится реализация методов для нескольких классов. В этом случае он разделяет группы методов, относящихся к разным классам.

Разрешается использовать данный разделитель также для разделения текста на разные смысловые группы везде, где это уместно. 

Длина строки-разделителя принимается равной 80 символов\footnote[1]{80 символов 12 шрифтом помещаются на одну строку листа формата А4 при полях справа и слева по 2 сантиметра.}. Как правило до строки-разделителя оставляется пустая строка.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Порядок методов внутри файла}

В начале файла, содержащего реализацию класса, должны располагаться конструкторы класса. Затем должен идти деструктор класса.

Методы, реализующие простые базовые операции с объектами класса, группируются в файле реализации и в объявлении класса по смыслу. Группировка таких методов в объявлении класса и в файле реализации должна быть одинаковой.

Методы, реализующие какие-либо нетривиальные алгоритмы, и вызываемые из этих методов приватные методы должны располагаться в файле реализации в порядке, соответствующем развернутому дереву вызовов. Допускается разворачивать дерево вызовов как от методов верхнего уровня к методам более низкого уровня, так и в обратном порядке.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Обработка длинных строк}

Строка считается длинной, если она не помещается в окно редактора \acsu{ide}, развернутое на весь экран. 

Длинная строка разбивается на две и более, причем вторая и последующие части сдвинуты на табуляцию.

В случае, если требуется распечатка на бумаге формата А4 файлов исходного кода <<как есть>>, то для сохранения нумерации строк и вида исходного файла, следует ограничить длину строки в 80 символов (также см.~\ref{subsubsection:Несколько_классов_в_одном_файле}).

Стоит отметить, что если распечатка на бумаге формата А4 файлов исходного кода <<как есть>> не предполагается (что разумно в современном мире), то при выборе длины строки следует ориентироваться на разрешение широкоформатного монитора (разрешение минимум 1440 на 900), при котором допустимы строки вплоть до 120 символов (с учетом бокового браузера файлов в \acsu{ide}).

Примеры:
\begin{lstlisting}[frame=single]
int ret = CreateDialog( GetApplicationObject()->MainWindow,
    filePath, nameDict, extensionsDict, currentFormat,
    dialogTitle );

for( const CWnd *wnd = GetFirst(); wnd != 0;
    wnd = wnd->GetNext() )
{
    wnd->EnableWindow( TRUE );
    wnd->ShowWindow( SW_SHOW );
}

int CMyClass::Func( int parameter1, int parameter2,
    int parameter3 )
{
}

СImageDialog::СImageDialog( СWnd *parent, int _format,
    const СString &_title ) :
    СDialog( parent, title ),
    format( _format )
{
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Использование пустых строк}

Пустая строка обязательно ставится между определениями (телами) методов и классов. Запрещается ставить несколько пустых строк подряд.

В остальных случаях расстановка пустых строк\mdash дело вкуса и здравого смысла программиста. Не нужно разделять пустыми строками все операторы, но и не нужно слитно писать метод на два экрана. Расстановка пустых строк должна делить текст на логически связанные части и, таким образом, улучшать читаемость текста.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Шаблонные методы и классы (template)}

\begin{lstlisting}[frame=single]
template<class T>
class СArray : public СBaseArray<T>
{
}

template<class T>
void СArray<T>::Add( const T &anElem )
{
}
\end{lstlisting}

Внутри угловых скобок пробелы не пишутся. Исключением является случай, когда аргументом шаблонного класса является другой шаблонный класс. В этом случае пробел между закрывающимися угловыми скобками требуется компилятору для разделения лексем. В этом случае пробелы пишутся симметрично:

\begin{lstlisting}[frame=single,numbers=none]
CPointerArray< CArray<CString> > myArray;
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{О декоративном форматировании}

Существует распространенная практика, которой следует избегать. Заключается она в том, что тексту стремятся придать <<красивый вид>> путем выравнивания нескольких подряд идущих строк по вертикали. 

Характерный пример:

\begin{lstlisting}[frame=single]
СWindow *Func1    ( int    param1 );
int      Func2    ( long   param2 );
void     Function ( LPCSTR param4 );
\end{lstlisting}

Применение такого декоративного форматирования ухудшает читаемость программы и создает дополнительные сложности при редактирование текста. Применять такой стиль форматирования текста запрещается.

Одни из немногих случаев, когда в середине строки может стоять более одного пробела подряд\mdash это описание инициализаторов для двумерных таблиц и написание inline ассемблера, где эта практика применяется традиционно. Во всех остальных случаях в середине строки более одного пробела подряд стоять не может.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Правила программирования}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Выбор типа переменной}

При выборе типа идентификатора необходимо пользоваться следующими соображениями:

\begin{enumerate}
\item если есть стандартный тип языка С++ подходящий для реализации переменной, то нужно им и пользоваться, а не изобретать typedef;

Разрешены типы:
\newline \lstinline|void, bool, char, wchar_t,|
\newline \lstinline|short, int, long,|
\newline \lstinline|float, double.|

Разрешены дополнительные типы:
\newline \lstinline|int8_t, int16_t, int32_t, int64_t,|
\newline \lstinline|uint8_t, uint16_t, uint32_t, uint64_t.|

\item \lstinline|short| рекомендуется использовать, например, при желании сэкономить память для размещения переменной. Если при этом нельзя гарантировать, что значение переменной ни при каких условиях не выйдет за границы, допустимые для переменных типа \lstinline|short|, необходимо менять \lstinline|short| на \lstinline|long| или \lstinline|int|;

\item типы \lstinline|int8_t, int16_t, int32_t| используются в случае, когда нужно явно указать количество байт (например при работе с внешним интерфейсом, файлами); 

\item нельзя пользоваться беззнаковым целочисленным типом переменных без крайней на то нужды;
\item запрещено использовать тип \lstinline|size_t|, кроме случаев, обусловленных стандартом языка, например, при определении оператора \lstinline|new|.

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Стандартный интерфейс метода (использование const и void)}

Интерфейс метода должен отображать характер работы метода с аргументами.

Если метод модифицирует входной аргумент, переданный по указателю или ссылке, или метод изменяет \lstinline|this|, то он должен возвращать \lstinline|void| или \lstinline|bool| (только для возврата информации об успешном завершении метода).

Если метод не изменяет входной аргумент, переданный по указателю или ссылке, или метод не изменяет \lstinline|this|, обязательно следует употреблять описатель \lstinline|const|. Этот описатель показывает, как метод использует аргумент и, таким образом, облегчает чтение. Кроме того, \lstinline|const| гарантирует от неправильного использования входных данных. 

Если метод не \lstinline|const| и необходимо выбрать: вернуть ли объект или использовать ссылку на модифицируемый объект и вернуть \lstinline|void|, то необходимо использовать 2\sdash й способ.

Пример 1: \lstinline|CString CString::MakeUpper() const;|

Пример 2: \lstinline|void CString::MakeUpper();|

Пример 3: \lstinline|CString &CString::MakeUpper(); // Ошибка стиля|

Напомним, что описатель \lstinline|const| также должен использоваться для полей класса, значения которых инициализируются в конструкторе и не меняются за время жизни объекта.

Особые правила относятся к методам контейнера, возвращающим ссылку на объект, находящийся внутри контейнера. Рекомендуется определить два метода с одинаковым именем: константный метод возвращает константную ссылку на объект, а не константный метод возвращает не константную ссылку.

Пример:

\begin{lstlisting}[frame=single]
class CMyContainer
{
    CMyObject &GetObject( int index );
    const CMyObject &GetObject( int index ) const;
};
\end{lstlisting}

Если константный по сути метод тем не менее модифицирует объект, например, вычисляя некоторые данные по требованию и запоминая их для последующего использования, то метод нужно объявлять как \lstinline|const|, а модифицируемые поля\mdash как \lstinline|mutable|.

%\newpage
Пример:

\begin{lstlisting}[frame=single]
enum TBloodType
{
    BT_A,
    BT_B,
    BT_AB,
    BT_O,
    BT_Unknown
};

class CPerson
{
public:
    TBloodType GetBloodType() const;
	
private:
    mutable TBloodType bloodType;
    TBloodType calculateBloodType() const;
};

inline TBloodType CPerson::GetBloodType() const
{
    if( bloodType == BT_Unknown ) {
        bloodType = calculateBloodType();
    }
    assert( BT_A <= bloodType && bloodType <= BT_O );
    return bloodType;
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Инициализация переменных и полей}

Следует всегда инициализировать локальные переменные и поля классов тех типов, которые не имеют специально созданных для этой цели конструкторов. Инициализировать локальные переменные нужно сразу при их объявлении, а поля классов во всех конструкторах этого класса.

\newpage
Пример:

\begin{lstlisting}[frame=single]
struct CStruct
{
    int Field1;
    IObject *Field2;
    CPtr<IObject> Field3;
    LOGFONT Field4;

    CStruct()
    {
        Field1 = 0;
        Field2 = 0;
        memset( &Field4, 0, sizeof( LOGFONT ) );
    }
};
\end{lstlisting}

За этим необходимо аккуратно следить, т.к. компилятор выдаёт предупреждение об использовании неинициализированных переменных только в самых простых случаях. При этом неинициализированное поле класса может стать причиной ошибки, которую будет нелегко воспроизвести.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование структур}

Структуры следует использовать в тех случаях, когда для них не определены никакие \lstinline|private| и \lstinline|protected| методы и поля, нет виртуальных функций и функций со сложной семантикой и не предполагается наследование. У структур могут быть явные конструкторы, но не должно быть явно описанного деструктора. У структур должны быть автоматически сгенерированные компилятором конструктор копирования и оператор присваивания. 

Структуры применяются вместо классов чтобы сообщить программисту, который будет читать программу, что объект имеет простую семантику и его использование не влечёт скрытых накладных расходов.

Пример:

\begin{lstlisting}[frame=single]
struct СMyData
{
    int Field1;
    int Field2;
};
\end{lstlisting}

Запрещено инициализировать структуры, используя список инициализаторов, без согласования с руководителем проекта.

Пример плохого стиля: \lstinline|CMyData data = { 1, 2 };|

Ограничение вызвано тем, что тяжело вручную поддерживать контроль соответствия данных и полей структуры. Если у структуры появляется новое поле, инициализация становится ошибочной.

При необходимости рекомендуется создать конструктор (с возможностью контроля данных) или метод инициализации, если есть массивы данных такого типа и по соображениям эффективности конструктор определять нежелательно.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Проверка значений указателей}

Язык C++ имеет выделенное значение для указателей: 0. Поэтому если в программе необходимо проверить равенство указателя нулю, это следует делать в виде явной проверки \lstinline|ptr != 0|. Запрещается использовать константу \lstinline|NULL| или использовать указатель как булевское значение. Лучше использовать ключевое слово \lstinline|nullptr|.

Пример правильной проверки:
\newline \lstinline|if( ptr != 0 )|

Примеры неправильных проверок:
\newline \lstinline|if( ptr != NULL )|
\newline \lstinline|if( !ptr )|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование адресов временных объектов}

Согласно стандарту C++ временные объекты живут до конца вычисления выражения:

\begin{lstlisting}[frame=single]
// Безопасно
MyFunc( ( str1 + str2 ).Ptr() );
MyFunc( GetText().Ptr() );

// Ошибка
return( str1 + str2 ).Ptr();
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Область видимости переменной цикла <<for>>}

Запрещено полагаться на область видимости локальной переменной, определённой в операторе инициализации оператора \lstinline|for|.

Если всё-таки требуется использовать переменную цикла после оператора \lstinline|for|, необходимо её определить до оператора цикла:

\begin{lstlisting}[frame=single]
int i = 0;
for( ; i < a.Size(); i++ ) {
	...
}
\end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Преобразование типа}

В языке C++ введён синтаксис для явного преобразования типа при помощи ключевых слов \lstinline|static_cast, const_cast, reinterpret_cast, dynamic_cast|. Для явного преобразования типа следует всегда пользоваться этими ключевыми словами. Использовать явные преобразования типа в стиле языка C запрещается. Это позволяет избежать следующих ошибок:

\begin{enumerate}
\item Снятие константности. Использование в этом случае \lstinline|const_cast| позволяет избежать ошибочного преобразования к указателю (ссылке) на объект другого типа.
\item Преобразование указателя (ссылки) от базы к потомку. Компилятор не диагностирует ошибочное использование преобразования типа в стиле языка С, когда потомок объявлен, но не определён. В этом случае такое преобразование работает как \lstinline|reinterpret_cast|, что приводит к ошибке, когда предок является не первой базой потомка. Использование \lstinline|static_cast| позволяет избежать подобной ошибки. 
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{О длине тела метода}

Методы должны содержать операторы, выполняющие однородные действия.

Пример <<плохого>> кода:
\begin{lstlisting}[frame=single]
void CMyClass::f()
{
    for( int i = 0; i < 1000; i++ ) {
        // Действия по инициализации
    }
    while( condition() ) {
        // Содержательные действия
    }
    for( int i = 0; i < 1000; i++ ) {
        // Действия по очистке
    }
}
\end{lstlisting}

%\newpage
Пример <<хорошего>> кода:
\begin{lstlisting}[frame=single]
void CMyClass::f()
{
    init();
    doSomething();
    cleanUp();
}
\end{lstlisting}

При этом названия методов более низкого уровня должны объяснять их семантику, а если семантика нетривиальна\mdash  должны быть исчерпывающие комментарии. %Формальным признаком неправильно написанного метода является его большая длина. Метод длиннее 30 строк считается подозрительным.
%С другой стороны, не следует вводить много мелких методов, не имеющих независимой семантики. Это может сильно затруднить чтение программы. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование логических переменных}

При проверке логического условия не следует сравнивать с \lstinline|true|.

Пример <<плохого>> кода:
\begin{lstlisting}[frame=single]
if( x == true ) {
    ...
}
\end{lstlisting}

Пример <<хорошего>> кода:
\begin{lstlisting}[frame=single]
if( x ) {
    ...
}
\end{lstlisting}

При присваивании значения булевской переменной или возврате булевского значения из функции запрещается использовать оператор \lstinline|?| с вариантами результата \lstinline|true| и \lstinline|false|. Т.е. нужно писать: 
\newline \lstinline|bool value = x > 0;|
\newline а не: 
\newline \lstinline|bool value = x > 0 ? true : false;|

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Деструкторы}

Поскольку при исключении происходит свертка стека и вызов деструкторов автоматических объектов, деструкторы не должны генерировать исключения, по крайней мере в release\sdash версии. Поэтому в деструкторах нельзя делать никаких сложных действий, могущих вызвать исключения. Кроме того, деструкторы не должны полагаться на состояние объекта или системы и на порядок вызова других деструкторов. Основная задача деструктора\mdash освободить ресурсы, занятые объектом, и оставить систему в корректном состоянии.

%\newpage
Рекомендации:

\begin{enumerate}
\item Отладочные проверки в деструкторах можно делать только макросом \lstinline|presume| (см.~раздел~\ref{subsubsection:assert}).
\item Объект, владеющий ресурсами, например, памятью или открытыми файлами, должен иметь указания, какими он ресурсами владеет в данный момент. Для этого можно использовать выделенные значения (0 для указателя) либо флаги.
\item При конструировании объекта все указатели должны быть инициализированы адресами существующих объектов либо нулем. При удалении объекта при помощи \lstinline|delete| указателю на объект нужно присвоить нуль.
\item Если в деструкторе приходится производить нетривиальные действия по освобождению ресурсов, которые могут приводить к генерации исключений, нужно поставить перехватчик исключений и (обычно) выдать пользователю сообщение об ошибке.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Битовые поля}

В некоторых случаях для уменьшения размера структуры используются битовые поля. Следует помнить, что если битовое поле используется для знакового типа, то один бит отводится под знак. Особое внимание следует обратить на битовое поле целочисленного знакового типа, например \lstinline|int, short|. Знаковое битовое поле размером один бит может представить только два значения: $0$ и $-1$, и не может представить значение равное $1$. Для булевских битовых полей следует использовать стандартный тип \lstinline|bool|.

Запрещается использовать битовые поля для перечисляемых типов. 

Вопрос об использовании битовых полей находится в компетенции руководителя проекта.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Опасные приемы}

Опасными называются приемы, приводящие к серьезным ошибкам, разрушающим программу: выходу величины за границы диапазона, обращению к неаллокированной памяти и т.п. Серьезные ошибки подобного рода не всегда легко отлаживаются и совершенно недопустимы в готовой программе. В оправдание <<опасных>> приемов и против защитного стиля иногда приводится довод о неэффективном коде, порождаемом защитным стилем. Удешевление разработки программ и существенное повышение надежности полностью оправдывают незначительное снижение скорости и умеренный рост объема кода. Наиболее часто встречающиеся опасные приемы перечислены ниже.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование буферов в памяти как массивов}

В языке C нет другого типа массивов, чем буфера в памяти. При индексации буфера в памяти не делается проверок на выход индекса за границы буфера. Еще опаснее использовать реаллокируемый буфер как динамический массив. Использование функций работы с блоками памяти из стандартной библиотеки делает программу почти не верифицируемой и очень ненадежной. Везде, где это возможно, следует использовать контейнеры стандартной библиотеки std.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование макросов}

Запрещается создавать новые группы связанных друг с другом макросов. Запрещается создавать макросы вместо inline-функций, шаблонов или констант.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование в программе явных числовых значений}

Запрещено использовать явные числовые константы кроме $0$ и $1$. Большинство нужных констант целой арифметики описаны в limits.h. Всем остальным константам в программе должны присваиваться символические имена с помощью \lstinline|enum| (сам \lstinline|enum| может быть неименованным ) или используя ключевое слово \lstinline|const|.

Из этого правила есть важное исключения: не нужно присваивать константе символическое имя, если выполняются следующие условия

\begin{enumerate}
\item Константа используется ровно в одном месте (константа не связана функциональными зависимостями с другими константами).
\item Константа имеет смысл только в контексте окружающего выражения.
\end{enumerate}

В этом случае смысл константы обязательно должен быть описан комментарием.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Код, маскирующий ошибку}

Запрещается вместо проверочного кода использовать код, маскирующий ошибку. Предположим, функция работы со строками в смысле С не должна получать нулевой указатель. Следовательно, одним из предусловий, проверяемых с помощью \lstinline|assert| (см. ниже), должно быть неравенство этого указателя нулю. Примером маскирования ошибки, будет функция, которая в случае равенства указателя нулю не будет делать ничего. Подобная практика есть грубейшее нарушение производственной дисциплины.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Выход из аварийной ситуации с минимальными потерями}

Необходимо учитывать, что реализация \lstinline|assert| в ряде проектов не прерывает выполнения программы. Следовательно, при срабатывании проверочного условия, после \lstinline|assert| в ряде случаев должен располагаться код, который бы позволил системе выйти из сложившейся ситуации с минимальными потерями. 

Кода обработки аварийных ситуаций должен быть нацелен на поддержание системы  в работоспособном состоянии. Например, если сбой произошёл в системе выдачи информации оператору, то достаточно выдать признак, что данные некорректны. Если сбой произошёл в одном из каналов многоканальной системы, то допустимо в крайних случаях вместо поступивших некорректных данных использовать какие-то значения по\sdash умолчанию. Аварийный код должен быть максимально простым, чтобы не усугубить ситуации.

%\newpage
Приведём ряд примеров.
\begin{enumerate}
\item Функции, работающие с массивами данных, в случае получения слишком больших объемов данных должны обрабатывать столько данных, сколько могут, или не делать ничего:
\begin{lstlisting}[frame=single]
void procData( const void *data, int size )
{
    if( size > MaxSize ) {
        assert( false );
        size = MaxSize;
    }
    doSomething( data, size );
}
\end{lstlisting}

\item Функции, работающие со строками, в нештатных случаях должны возвращать пустую строку:
\begin{lstlisting}[frame=single]
const char *GetStateName( TPrepareState state ) 
{
    switch( state ) {
        case PS_NoDevice:
            return "NoDevice";
        case PS_BrokenChannel:
            return "Broken";
        ...
        default:
            assert( false );
            return "";
    }
}
\end{lstlisting} 

\item Функции, возвращающие ссылку на объект по его идентификатору, в случае получения некорректного идентификатора после \lstinline|assert| должны возвращать ссылку на специально предусмотренный <<мусорный>> объект:
\begin{lstlisting}[frame=single]
static CTarget target[MaxTarget + 1];
CTarget &GetTarget( int iTarget )
{
    if( iTarget >= 0 && iTarget < MaxTarget ) {
        return target[iTarget];
    } else {
        assert( false )
        return target[MaxTarget];
    }
}
\end{lstlisting} 

\end{enumerate}

В случае ошибок, которые могу быть вызваны только общесистемными проблемами, писать аварийный код не следует. Например, если функция получает данные через указатель и этот указатель в принципе не может быть равен 0, то проверять указатель на ноль не имеет смысла. Первое обращение к этому указателю приведёт к генерации исключения, что позволит быстро найти ошибку.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Специальные значения}

Одним из признаков плохо спроектированного интерфейса является наличие у методов параметров, специальные значения которых сильно меняют семантику этих методов. Также вредны специальные возвращаемые значения. Специальные значения плохи тем, что делают семантику интерфейса крайне запутанной, и это приводит к ошибкам. 

Использование специального значения параметра оправдано в редких исключениях и должно в каждом случае специально обосновываться. Избежать этого можно, к примеру, введением дополнительных входных параметров или дополнительных методов.

Использованию специальных возвращаемых значений следует предпочесть систему обработки ошибок либо введение дополнительных выходных параметров.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Управление динамической памятью}

Запрещается использовать какие\sdash либо средства распределения памяти кроме \lstinline|new| и \lstinline|delete| или умных указателей (приоритетнее).

%В ряде проектов запрещена аллокация памяти в процессе работы при решении задач применения по назначению. Память, необходимую подсистеме, необходимо выделять статически или аллокировать при старте подсистемы. В частности в процессе работы не следует выполнять не константные операции с объектами типа std::string.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Функции с переменным числом параметров}

Функции с переменным числом параметров (например, функция \lstinline|printf|) обычно определяют количество своих параметров и их тип в результате анализа значения других параметров этой функции. Контроль типа параметра компилятором отсутствует. Это может приводить к ошибкам, которые проявляются только во время выполнения программы. Использовать функции с переменным числом параметров запрещается без разрешения руководителя проекта.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Функции scanf, strcpy, strcat}

Применение этих функций часто приводит к порче памяти, так как невозможно проконтролировать отсутствие переполнения буфера, в который копируется строка. Эти функции использовать запрещено.

Для работы со строками нужно использовать класс \lstinline|std::string|. В случае крайней необходимости работы с низкоуровневыми строками нужно использовать функцию \lstinline|strncpy|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Оператор goto}

%Про вред бесконтрольного использования \lstinline|goto| много написано в классической литературе.

Использование оператора \lstinline|goto| является классической темой для holy war.

В некоторых языках, например FORTRAN, использование данного оператора полностью оправданно.

В языке C++ использование оператора \lstinline|goto| может быть оправданно только в нескольких случаях: досрочном прерывании нескольких вложенных циклов и использования legacy-кода. В обоих случаях показан code-review. Запрещается использовать оператор \lstinline|goto| в иных случаях.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Целая арифметика}

Опасна беззнаковая арифметика, где переполнение происходит в области малых по модулю чисел. Вычитания беззнаковых чисел следует избегать, а если нельзя\mdash производить крайне осторожно, с предварительным сравнением. Можно также преобразовывать беззнаковый тип в знаковый большего размера, делать вычисления, а при обратном преобразовании производить проверку на диапазон.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование ассемблера}

Использование ассемблера относится к опасным приемам программирования. Оно допускается только при обоснованной необходимости оптимального кода или невозможности достичь требуемого результата высокоуровневыми средствами. Кроме того, написать на ассемблере процедуру, более эффективную, чем соответствующая процедура на C, достаточно трудно.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Формулировка условий цикла}

Следует очень тщательно подходить к формулированию условий циклов. В качестве условия цикла следует использовать логическое выражение, которое выполняется только для допустимых значений переменной цикла. Например, не следует вместо \lstinline|i < 100| писать \lstinline|i != 100|, т.к. такое условие может привести к ошибке, если после каждой итерации цикла значение переменной цикла увеличивается на отличное от единицы число.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование статических объектов}

Использования сложных статических объектов следует избегать по следующим причинам:

\begin{enumerate}
\item Зависимости между различными статическими объектами приводят к тому, что работа программы зависит от порядка вызова конструкторов и деструкторов этих объектов, а этот порядок для объектов из разных модулей не определен. Наличие зависящих друг от друга статических объектов практически всегда является следствием ошибок в архитектуре системы.
\item о время вызова конструкторов и деструкторов статических объектов затруднена обработка исключений. Исключение, сгенерированное в конструкторе или деструкторе статического объекта и не перехваченное в этом конструкторе или деструкторе, приведет к завершению приложения без адекватной диагностики.
\end{enumerate}

Поэтому разрешается использовать статические объекты только простых типов с тривиальными конструкторами и деструкторами. Также разрешается использовать глобальные статические объекты библиотечных классов, таких как \lstinline|std::string|. Использовать статические объекты пользовательских типов с нетривиальными конструкторами или деструкторами и статические массивы из таких объектов запрещается. Данный запрет относится к статическим и глобальным объектам, статическим полям классов и статическим переменным внутри функций.

Категорически запрещается определять статические переменные нетривиальных, в том числе библиотечных, типов внутри функций. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Использование деструктора массива}

После использования оператора \lstinline|new| для создания массива, необходимо пользоваться оператором \lstinline|delete| для массива. 

Пример:
\begin{lstlisting}[frame=single,numbers=none]
char *p = new char[20];
...
delete[] p;  // Нельзя использовать delete p;
\end{lstlisting} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование шаблонов}

С помощью шаблонных классов и функций довольно легко создать код, трудный для понимания и отладки. Поэтому создание собственных шаблонных классов и функций, не входящих в стандартные библиотеки, допускается только с разрешения руководителя проекта.



