\newpage
\section{Стиль программирования}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Использование стандартных программных средств}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Использование стандартных библиотечных средств облегчает процесс разработки, уменьшает число ошибок и повышает понятность кода. Кроме того, оно сильно облегчает перенос кода между различными операционными системами и вычислительными средствами. 

Рекомендуется применять следующие стандартные средства и средства из состава репозитория операционной системы:

\begin{enumerate}
\item стандартная библиотека \lstinline|std::|;
\item библиотека Boost~\cite{Boost};
\item библиотека Armadillo (работа с матрицами)~\cite{Armadillo}.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsection{Правила разработки классов на C++}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{О минимальной достаточности классов}

Не следует пытаться разрабатывать чрезвычайно общие классы. Практика показывает, что разработать удачный класс с достаточно общей семантикой сложно даже для опытного разработчика. Общие классы обычно имеют сложную, плохо определенную семантику и крайне смутные правила использования.

Разработка прикладного класса должна начинаться с четкого определения целей и условий его использования. После этого разрабатывается семантика (описание методов) класса, реализующего поставленную задачу. Набор методов класса должен быть минимально достаточен. Необходимо, чтобы описание класса содержало не только семантику, но и правила использования в виде примеров с подробными и ясными комментариями.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Использования наследования}

Наследование\mdash сложное в использовании средство, поэтому на практике им легко злоупотребить. Излишнее использование наследования приводит к сложным иерархиям классов, в которых нелегко понять семантику отдельного класса и решить, в каком классе нужно реализовать тот или иной метод.

Можно выделить четыре случая правильного использования наследования.

\begin{enumerate}
\item \textbf{Конкретизация при классификации}. Это основное использование наследования. Примером может служить наследование класса \lstinline|CTeacher| от \lstinline|CPerson|. Наследование при конкретизации практически никогда не бывает множественным, поскольку сложные классификации, действительно требующие множественного наследования, встречаются очень редко. Очень желательно, чтобы предок\sdash надкласс был первым предком.
%
\item \textbf{Использование библиотечных средств}. Распространенный способ использования библиотеки классов\mdash наследование потомка из абстрактного библиотечного предка.
%
\item \textbf{Реализация интерфейсов}. Если интерфейс задан абстрактным классом, то объект, реализующий этот интерфейс, наследуется из абстрактного класса\mdash интерфейса и реализует его виртуальные методы. Если объект реализует несколько интерфейсов, что бывает достаточно часто, используется множественное наследование. Если у класса есть обычный предок и предки\mdash интерфейсы, то обычный предок должен быть первым предком, а интерфейсы\mdash вторыми.
%
\item \textbf{Использование механизма}. Использование механизма путем наследования отличается от предыдущих случаев тем, что там наследование было открытое (\lstinline|public|), а здесь\mdash приватное (\lstinline|private|) или защищенное (\lstinline|protected|). Это вызвано тем, что механизм есть деталь реализации, несущественная для клиентов класса. Механизмы можно делать полями класса, но у наследования есть два преимущества:
	\begin{enumerate}
	\item cинтаксическая краткость;
	\item возможность переопределить виртуальные методы механизма и дать этим методам доступ к внутренним данным класса.
	\end{enumerate}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\paragraph{Разрешение конфликта имен при множественном наследовании}

При реализации интерфейсов с помощью множественного наследования иногда возникает конфликт имен, когда методы разных предков имеют одинаковые имена и параметры. При этом методы могут иметь разную семантику, а в потомке их нельзя переопределить по-разному. Конфликт имен решается путем введения промежуточных предков:

\begin{lstlisting}[frame=single]
class A
{
public:
    virtual int f();
};

class B
{
public:
    virtual int f();
};

class A_in_C : public A
{
public:
    virtual int f() { return A_f(); }
    virtual int A_f() = 0;
};

class B_in_C : public B
{
public:
    virtual int f() { return B_f(); }
    virtual int B_f() = 0;
};

class C : public A_in_C, public B_in_C
{
    virtual int A_f() { ... }
    virtual int B_f() { ... }
};
\end{lstlisting} 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\paragraph{Виртуальное наследование}

Виртуальное наследование нужно, чтобы предок при повторном наследовании был в потомке в единственном экземпляре. Данная ситуация известная также под названием ромбовидного наследования или <<алмаза смерти>> (diamond of death):

\illustration[][Пример виртуального наследования][0.6]{virtual1}[fig:virtual1]

В приведенном примере класс D будет содержать одну копию класса A. Причины, по которым такое наследование названо <<виртуальным>>, а не, например, <<разделяемым>> (shared), остаются за кадром. В стандарте принято ключевое слово \lstinline|virtual| для такого наследования.

В большинстве случаев использование виртуального наследования не оправдано. В качестве примеров разделяемого наследования можно привести следующие иерархии:

\newpage
\begin{enumerate}
\item Типы окон:
\illustration[][Иерархия классов типов окон][0.6]{virtual2}[fig:virtual2]
\item Персонал университета:
\illustration[][Иерархия классов персонала университета][0.6]{virtual3}[fig:virtual3]
\end{enumerate}

Первый случай\mdash просто ошибка проектирования, которая приводит к серьезным проблемам в реализации например метода Draw потомка. Естественная реализация, а именно последовательный вызов соответствующих методов предков, приводит к тому, что само окно рисуется дважды. Гораздо проще сделать рамку и меню полями окна, и отказаться от наследования вовсе.

Во втором случае применение виртуального наследования кажется более оправданным. Тем не менее существует достаточно простой альтернативный подход:

\illustration[][Иерархия классов персонала университета с применением интерфейсов][0.6]{virtual4}[fig:virtual4]

Здесь \lstinline|IStudent| и \lstinline|ITeacher|\mdash интерфейсы, частично содержащие реализацию. Хотя сущностей получается больше, не возникает технических проблем, неизбежных при разделяемом наследовании.

%Единственный случай, когда разрешается использовать виртуальное наследование\mdash это наследование интерфейсов из библиотечного класса IObject, содержащего реализацию счетчика ссылок. Любой класс, реализующий один или несколько интерфейсов должен иметь один счетчик ссылок. Поэтому, в таком классе должна быть одна копию объекта IObject. Следовательно, наследование интерфейса из IObject должно быть виртуальным.

%Таким образом, использование наследования выглядит следующим образом:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{О конструкторе копирования и операторе присваивания}

Если класс использует \lstinline|new| для аллокации данных, у него должен быть описан конструктор копирования и оператор присваивания. Если, исходя из семантики класса, у него не должно быть конструктора копирования либо оператора присваивания, такой метод нужно описать как \lstinline|private|, не определяя его. При этом нужно написать соответствующий комментарий.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{О виртуальном деструкторе}

У каждого класса, имеющего виртуальные функции, должен быть описан виртуальный деструктор. Класс, который может быть вторым предком другого класса, обязательно должен иметь виртуальный деструктор.

Исключением из этого правила являются интерфейсы в стиле COM с подсчётом ссылок, у которых традиционно нет виртуальных деструкторов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{О переопределении операций}

Если у класса переопределяется оператор, нужно также переопределить близкие операторы. 

Если у класса определён оператор \lstinline|==|, нужно также определить и оператор \lstinline|!=|. Если у класса переопределён \lstinline|operator *|, нужно также переопределить и \lstinline|operator ->|.

Семантика переопределенных операторов должна быть подобна семантике встроенных операторов для базовых типов.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование explicit конструкторов}

Если в классе определен конструктор с одним параметром, то этот конструктор может использоваться для неявного преобразования типа. В некоторых случаях это может привести к нежелательным последствиям. Например, у класса \lstinline|CFile| может быть конструктор от строки, задающей имя файла. Этот конструктор открывает файл. Если неявное преобразование разрешено, то в функцию, получающую в качестве аргумента константную ссылку на файл можно будет передавать строковые константы. Такое преобразование затрудняет понимание кода программы и может быть источником ошибок. Для запрета неявного преобразования необходимо объявлять конструктор как \lstinline|explicit|.

Конструкторы, выполняющие какие-либо нетривиальные действия (например, открытие файла), обязательно нужно объявлять \lstinline|explicit|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Использование ссылок и указателей}

Отношение владения между объектами всегда описывается при помощи указателя. Не существует владеющей ссылки.

Если объекту нужно иметь доступ к другому объекту, который за время жизни первого объекта не будет уничтожен или заменен на другой, то нужно запоминать в первом объекте константную ссылку или константный указатель на второй объект. Это будет указывать на неизменность второго объекта за время жизни первого.

Если объект, на который указывают, нужно заменять, в качестве поля нужно использовать указатель, а методы доступа могут возвращать ссылку.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование указателей и ссылок в параметрах функции}

Если в качестве параметра не нужно передавать нулевой указатель для обозначения пустого объекта, лучше использовать ссылку. Это облегчает чтение кода функции и позволяет избежать излишней проверки на равенство указателя нулю.

Ссылка, передаваемая в качестве параметра функции, может быть константной и не константной. Не константная ссылка на объект используется в качестве параметра функции только в том случае, если функция в соответствии со своей семантикой модифицирует этот объект.

Если такой объект не может модифицироваться функцией, то для передачи его в качестве аргумента функции следует использовать константную ссылку либо передавать его по значению. При этом атомарные типы следует всегда передавать по значению. Короткие структуры размером до четырёх байт с тривиальным конструктором копирования также лучше передавать по значению, если структура длиннее четырёх байт или имеет нетривиальный конструктор копирования, её следует передавать по константной ссылке.

В общем случае следует руководствоваться следующим правилом: атомарные типы всегда передаются по значению, структуры (классы) передаются по константной ссылке. Неконстантная ссылка используется только в том случае, если функция использует параметр в качестве одного из возвращаемых значений.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{О защитном стиле программирования}

Защитным называется стиль программирования, направленный на облегчение тестирования и отладки и повышение надежности программы. Чтобы программировать защищено, нужно избегать опасных приемов программирования и использовать в нужных местах проверочный код.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Что такое assert} \label{subsubsection:assert}

Для различных проверок во время выполнения программы используется макрос \lstinline|assert|, параметром которого является логическое выражение. В момент выполнения программы это выражение вычисляется, и если получен результат \lstinline|true|, то ничего не происходит и выполнение продолжается дальше. Если же получено значение \lstinline|false|, то происходит аварийный останов и на экране печатается имя файла и номер строки, где произошла ошибка.

Столь простая команда приводит к сокращению времени отладки программы на порядок и многократному облегчению тестирования, поскольку правильность работы программы контролируется не только человеком по результатам работы, но и самой программой изнутри в течении всего времени ее работы.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Принцип взаимного недоверия}

Каждый модуль для своего функционирования ожидает определенного поведения со стороны его окружения. Основной принцип состоит в том, что модуль проверяет результаты всех взаимодействий с другими единицами программы. Часто можно слышать оправдания вроде <<Я сам написал тот модуль и я знаю, что в нем нет ошибок>> или <<Я знаю, что тот модуль проверяет результаты своей работы>> или <<Код становится слишком раздутым>>. Первые два возражения говорят о лености и о непонимании принципов построения надежной программы, а последнее почти полностью снимается системой обработки ошибок с помощью исключений (взамен обычных кодов возврата).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsubsection{Где ставить assert?}

В ходе написания метода, модуля, класса делается много явных и еще больше неявных предположений о состоянии внешней среды. Нужно наиболее полно уяснить себе, в каких предположениях работает данная часть кода, и явным образом отразить это в программе с помощью \lstinline|assert|. В спецификациях методов нужно в явном виде указывать условия, которые должны быть выполнены перед вызовом, а в начале тела метода с помощью \lstinline|assert| проверять эти условия. Не следует забывать проверять не только входные параметры методов, но и внешние переменные, поля объекта и другие компоненты окружения, используемые методом. 

%При выполнении данных рекомендаций, условие выполнения \lstinline|assert| служат еще и для документирования текста программы. 

Таким образом рекомендуется ставить \lstinline|assert| в следующих случаях.

\begin{enumerate}
\item Для проверки входных параметров функции/метода и других компонент окружения, используемых данной функцией/методом.

\item Если вызывается внешний для данного класса метод и от него ожидается какой\sdash то определенный результат, проверять соответствие полученного ожидаемому. Особенно это актуально для внешних по отношению к разрабатываемой единице методов (другая подсистемы программы, операционная система). Следует явно формулировать постусловия методов и проверять их перед возвратом из метода.
\end{enumerate}

Количество проверок, которые можно вставить в код программы, огромно. Проверки могут быть как тривиальными, так и очень сложными. Всегда необходимо находить разумный компромисс между числом проверок и степенью защищенности программы от ошибок.

К сложным проверкам, требующим существенных вычислений и объема кода, следует прибегать только в редких случаях, поскольку такие проверки сами служат источником ошибок.

Наиболее полезны тривиальные проверки, поскольку они почти не влияют на эффективность, не вносят дополнительных ошибок и достаточно хорошо обнаруживают сбои в программе.

Для проверок иногда полезны избыточные данные, например поля, указывающие на состояние объекта.

Код, исправляющий последствия ошибки, очень трудно отлаживается, и почти всегда сам содержит ошибки. Поэтому этот код не должен быть слишком сложен и должен делать только самые необходимые действия.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Assert и presume}

Макрос \lstinline|presume| в отличие от \lstinline|assert| отключается в окончательной версии программы для повышения быстродействия. Можно указать несколько правил, когда ставить \lstinline|assert|, а когда \lstinline|presume|.

\begin{enumerate}
\item В некритических по быстродействию местах нужно ставить \lstinline|assert|.
\item Если нарушение условия приводит к разрушению программы, например, выход индекса за границы массива при записи, нужно ставить \lstinline|assert|.
\item Если условие служит отладочным целям, и нельзя стопроцентно гарантировать его выполнения, нужно ставить \lstinline|presume|.
\item В деструкторах нужно использовать \lstinline|presume|.
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Классы как типы данных и механизмы}

Существуют две разновидности классов объектов: типы данных и механизмы.

Тип данных представляет собой реализацию сущности предметной области с некоторым набором операций. Семантика операций может быть описана в виде набора аксиом. Тип данных не имеет внутреннего состояния в том смысле, что любая операция может быть применена к объекту данного типа в любое время.

Механизм представляет собой реализацию некоторого алгоритма. Обычно механизм имеет три основных типа операций: инициализацию, выполнение работы и извлечение результатов. При этом операции выполняются в строгой последовательности: механизм создается, инициализируется, работает, из него считывают результаты, он уничтожается. Например:

\begin{lstlisting}[frame=single]
class CSpaceFinder
{
public:
    CSpaceFinder( const Cline &line ); // Объект рассчитан на 
        // однократное использование, инициализация в
        // конструкторе
    void Process(); // Выполнение алгоритма
    int GetSpaceWidth() const; // Получение результата

private:
    ...
};
\end{lstlisting}

Поля механизма хранят настроечные параметры и промежуточные данные. В необъектном программировании механизму соответствует группа функций с промежуточными статическими данными.

Необходимость в специальном механизме возникает, когда появляются промежуточные данные, хранящие состояние алгоритма. Основное отличие механизма от нормального типа данных заключается именно в наличии промежуточных состояний.

В принципе возможны классы, имеющие свойства и типов данных, и механизмов. Можно представить механизм, который после работы ведет себя как нормальный тип данных. Однако лучше избегать таких ситуаций и выделять два класса: механизм и тип данных, порождаемый механизмом. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Внешние форматы и обеспечение обратной совместимости}

Новая версия системы должна (но не обязательно!) поддерживать внешние форматы более старых версий. Совместимость новой версии с предыдущими будем называть обратной совместимостью. Для этого существует несколько приемов изложенных далее.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Флаги}

Флаги (битовое множество) позволяют, пока есть место, добавлять новые бинарные атрибуты без изменения физической структуры данных. Нужно лишь инициализировать неиспользуемые флаги и игнорировать их значение.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Сохранение номера версии}

Флаги годятся лишь для передачи бинарных атрибутов. Более общим решением является сохранение во внешнем формате номера версии для каждой структуры данных. Код считывания выглядит следующим образом. Сначала считывается номер версии. Затем этот номер сравнивается оператором \lstinline|switch| с номером текущей версии и всех предыдущих. Для каждого случая вызывается соответствующий код считывания, а отсутствующие в старых версиях поля инициализируются значениями по умолчанию.

Если считанный номер версии превосходит текущий номер, то это означает что файл данных создан более новой версией программы и от его считывания нужно отказаться.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{Интерфейсы между подсистемами}

Различные подсистемы взаимодействуют друг с другом через интерфейсы. Интерфейсом называется абстрактный класс, содержащий только чисто виртуальные методы и не содержащий данных.

%Библиотека стандартных программных средств (Aspm) содержит определение интерфейса IObject, из которого следует выводить все остальные интерфейсы. Интерфейс IObject содержит методы подсчета ссылок. Явные вызовы методов увеличения и уменьшения счетчика ссылок не нужны, т.к. библиотека содержит шаблонный класс CPtr для указателей на интерфейсы – наследники IObject. Класс CPtr вызывает методы подсчета ссылок во всех нужных случаях.

Одна подсистема может реализовывать несколько интерфейсов. Для реализации интерфейса необходимо создать класс\mdash наследник абстрактного интерфейса, определить все его виртуальные методы и предоставить средство для создания объектов этого класса. Один объект может реализовывать несколько интерфейсов. В этом случае применяется множественное наследование. Для получения указателя на какой\sdash либо интерфейс объекта по указателю на другой интерфейс необходимо использовать преобразование типа с помощью \lstinline|dynamic_cast|.

%Существует несколько способов создания объектов, реализующих какие\sdash либо интерфейсы:

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsection{Когда нужно заботиться об эффективности программы?}

Есть два противоположных подхода к оптимизации программы:

\begin{enumerate}
\item Сначала программа должна заработать, а затем ее нужно оптимизировать
\item Об эффективности нужно думать с самого начала. Если проектные решения неэффективны, оптимизировать потом будет поздно.
\end{enumerate}

В действительности оба подхода с определенной точки зрения справедливы и не противоречат друг другу. При проектировании и разработке программы нужно постоянно учитывать соображения эффективности, чтобы основные решения не были неисправимо неэффективны. Но на этом этапе не нужно тратить усилия на достижение максимальной эффективности и микрооптимизацию. После того, как программа заработала, можно снять профиль и провести требуемую оптимизацию.

Существует много приемов, дающих выигрыш в микроэффективности. Однако в подавляющем большинстве случаев микроэффективность никак не отражается на скорости работы программы. Дешевизна разработки и надежность гораздо важнее микроэффективности. Заботьтесь о надежности и читаемости Ваших исходных текстов, а об эффективности подумает руководитель проекта.

Настоятельно рекомендуется применять вместо обычных указателей на пользовательские объекты умные указатели (\lstinline|unique_ptr,  shared_ptr, weak_ptr, auto_ptr|). Умные указатели нужны для того, чтобы автоматизировать контроль за временем жизни ресурса (динамического объекта, как частный случай). Чтобы код был написан так, что забота о корректном освобождении ресурса ложилась на компилятор (посредством вызова деструктора). Это повышает надежность работы программы и облегчает процесс проектирования и отладки.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsection{Работа с include файлами}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Имена файлов}

Рекомендуется использовать длинные имена файлов. Имена файлов пишутся с маленькой буквы (во избежание проблем при переносе кода на \acsu{ос} типа UNIX). Файлу, содержащему описание либо реализацию некоторого класса, имя даётся по названию описываемого в файле класса без начальной буквы <<C>>. В конце через точку приписывается необходимое расширение. Например, класс \lstinline|CProgramCodeBuilder| должен быть объявлен в файле \lstinline|programmcodebuilder.h|, а его реализация\mdash в \lstinline|programmcodebuilder.cpp|.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Оформление заголовочных файлов}

Каждый заголовочный файл \lstinline|<fileName_h>| должен начинаться со строк: 

\begin{lstlisting}[frame=single,numbers=none]
#ifndef fileName_h
#define fileName_h
...
#endif //fileName_h
\end{lstlisting}

Такая конструкция гарантирует, что текст не будет обработан компилятором дважды.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Включение include файла}

Запрещено использовать в качестве имен пользовательских файлов полные либо относительные пути. Все нестандартные каталоги, из которых берутся включаемые файлы, описываются в опциях проекта.

\begin{lstlisting}[frame=single,numbers=none]
#include <src/myheader.h> // Запрещено!
#include <myheader.h> // Правильно
\end{lstlisting}

Исключение может составлять использование библиотек типа Boost, где традиционно принято подключение вида:

\begin{lstlisting}[frame=single,numbers=none]
#include <boost/asio.hpp>
#include <boost/core/noncopyable.hpp>
\end{lstlisting}

Имя включаемого заголовочного файла всегда указывается в угловых скобках. Использовать кавычки для указания имён файлов запрещено:

\begin{lstlisting}[frame=single,numbers=none]
#include "myheader1.h" // Запрещено!
#include "../inc/myheader2.h" // Запрещено!
\end{lstlisting}

Первым включаемым в cpp-файл заголовочным файлом должен быть соответствующий этому cpp-файлу заголовок. Работа cpp-файла не должна зависеть от последовательности включения заголовочных файлов, следующих за первым заголовочным файлом.

В опциях проекта указываются пути для поиска включаемых файлов. При этом перечисляются все подкаталоги каталога проекта, в которых содержатся требуемые файлы. Кроме того, указываются стандартные каталоги, содержащие описания библиотек. Если включаемые файлы находятся в одном каталоге с проектом, то в списке путей надо указать символ <<.>>. 

Категорически запрещается указывать в опциях компиляции полные пути, содержащие имя диска или название компьютера. Для задания путей на каталоги, которые не являются подкаталогами проекта, необходимо использовать переменные окружения или относительные пути.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Использование предкомпиляции (precompiled headers)}

Компилятор C++ поддерживает предкомпиляцию \lstinline|include| файлов. Для эффективного использования этого средства каждый \lstinline|*.cpp| файл проекта начинается со строк:

\begin{lstlisting}[frame=single,numbers=none]
#include <common.h>
#pragma hdrstop
\end{lstlisting}

При этом для файла \lstinline|common.cpp|, содержащего только указанные две строчки, устанавливается опция <<Create precompiled header file (.pch)>>, а для остальных файлов проектов\mdash <<Use precompiled header file (.pch)>>. Имя загловочного, по которому осуществляется предкомпиляция указывать не нужно. Использовать опцию <<Automatic use of precompiled headers>> не рекомендуется, так как её использование существенно замедляет процесс компиляции.

Файл \lstinline|common.h|\mdash это специальный файл, который содержит в себе несколько строк, директив \lstinline|include| для препроцессора. Обычно в него включают наиболее часто используемые в проекте \lstinline|include| файлы стандартных библиотек. Кроме этого допустимо в \lstinline|common.h| помещать директивы препроцессора, управляющие оптимизацией, например \lstinline|#pragma inline_depth( 30 )|. Все содержимое \lstinline|common.h| может быть удалено без изменения работоспособности программы, поэтому нельзя полагаться на то, что в \lstinline|common.h| включаются какие\sdash то файлы. Единственное его назначение\mdash оптимизация времени компиляции.

Запрещается вносить в \lstinline|common.h| какие либо другие строки кроме описанных выше.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\newpage
\subsubsection{Избыточные зависимости}

При программировании на языке C++ возникает проблема избыточных зависимостей \lstinline|*.cpp| файла от \lstinline|*.h| файлов. Она возникает из\sdash за того, что интерфейс класса и детали его реализации (\lstinline|protected| и \lstinline|private| поля, \lstinline|inline| методы) должны быть размещены в одном \lstinline|*.h| файле. При этом в \lstinline|*.h| файл включаются другие \lstinline|include|\sdash файлы, необходимые для описания \lstinline|protected| и \lstinline|private| полей или для реализации \lstinline|inline| методов. Это приводит к тому, что модуль перекомпилируется при изменении любого из включаемых в него \lstinline|include|\sdash файлов, хотя реальной зависимости от большинства из них нет. Основной принцип решения этой проблемы\mdash отделять реализацию от интерфейса.

Кроме того, существуют следующие рекомендации.

\begin{enumerate}
\item Если в \lstinline|include|\sdash файле используется только указатель или ссылка на объект класса \lstinline|X|, не следует включать заголовочный файл с описанием этого класса. Достаточно его объявить следующим способом: \lstinline|class X;|
%
\item Не нужно выносить в \lstinline|include|\sdash файл реализацию нетривиальных \lstinline|inline|\sdash методов, поскольку возникает зависимость от реализации даже тех модулей, которые не используют эти методы. Если метод не критичен по быстродействию, то лучше сделать его обычным; если метод критичен по быстродействию, его нужно описать в отдельном файле с расширением \lstinline|.inl| и включать этот файл только куда надо. Таким же образом можно бороться и с циклическими зависимостями файлов.
%
\item Не следует выносить в \lstinline|include|\sdash файл объявления тех констант, классов и типов, которые не относятся к интерфейсу. Их можно описывать прямо в модуле с реализацией либо в отдельном \lstinline|include|\sdash файле, если модулей несколько.
\end{enumerate}